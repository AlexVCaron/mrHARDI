// Parameter sections initialization
params.config = {
    denoise = { }
    measure = { }
    preprocess = { }
    reconstruct = { }
    register = { }
    utils = { }
    workflow = {
        preprocess = { }
        reconstruct = { }
        measure = { }
    }
}

params.metadata = {}

// BASIC RESOURCES ALLOCATION FOR PROCESSES

// Use gpu if available
params.use_cuda = true

// Resources conservation
params.conservative_resources = true
params.free_processes = 1
params.memory_buffer_gb = 8

// HCP allocation parameters
params.max_parallel_tasks = 10
params.submit_rate = 30  // seconds
params.additional_cluster_opts = ""
params.max_time_per_task = null
params.queue_type = null


// IO PARAMETRIZATION

// Inputs declaration
params.data_root = "tmp/input"
params.metadata.dwell = 0.062487
params.metadata.multiband = 2
params.metadata.gslider = 5
params.metadata.interleaved = true
params.metadata.slice_direction = "SI"
params.metadata.direction = "AP"
params.metadata.acquisition = "Linear"
params.multiple_reps = false
params.rev_is_b0 = false
params.masked = true

// Outputs declaration
params.output_root = "outputs"
params.publish_all = true
params.publish_mode = "copy"
params.verbose_outputs = false
params.resampling_resolution = 0.4


// WORKFLOWS PARAMETRIZATION

// Global preprocessing parameters
params.intensity_normalization = false
params.resample_data = false

// T1 preprocessing parameters
params.masked_t1 = true
params.t1mask2dwi_registration = true
params.register_t12b0_denoised = false
params.denoise_t1 = false
params.nlmeans_t1 = false

// DWI preprocessing parameters

// Initial denoising
params.gaussian_noise_correction = false
params.gibbs_ringing_correction = false

// Topup
params.topup_correction = false

// Eddy
params.eddy_correction = false
params.post_eddy_registration = true
params.eddy_force_shelled = true
params.eddy_on_rev = true
params.eddy_pre_bet_mask = false

// DWI reconstruction parameters
params.reconstruct_use_mrtrix = true

// DTI
params.recons_dti = true

// CSD
params.recons_csd = true
params.convert_tournier2descoteaux = true
params.frf_fa = 0.7
params.frf_min_fa = 0.5
params.frf_min_nvox = 200

// DIAMOND
params.recons_diamond = true

// Miscellaneous
params.bet.f = 0.65

// Resources allocation -- DO NOT TOUCH --
import com.sun.management.OperatingSystemMXBean
import java.lang.management.ManagementFactory
if ( !executor || executor.name == "local" ) {
    def count = 0
    def avail_cpus = 0
    while ( count < 10 ) {
        check_cpus = Runtime.runtime.availableProcessors()
        avail_cpus = (check_cpus > avail_cpus) ? check_cpus : avail_cpus
        count += 1
    }

    if ( params.processes ) {
        if(params.processes > avail_cpus) {
            throw new RuntimeException(
                "Number of processes higher than available CPUs."
            )
        }
        else if(params.processes < 1) {
            throw new RuntimeException(
                "When set, number of processes must be >= 1 " +
                "and smaller or equal to the number of CPUs."
            )
        }
    }
    else {
        params.processes = avail_cpus
    }

    def sysmem = ((OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean()).getTotalPhysicalMemorySize() / 1073741824
    if ( params.memory_buffer_gb )
        sysmem -= params.memory_buffer_gb

    executor.$local.memory = "${sysmem}GB"
    executor.$local.cpus = params.processes

    //println("Using local executor with ${executor.$local.cpus} processes and ${executor.$local.memory} of memory")
}

process {
    withLabel: res_full_node { cpus = params.processes }
    withLabel: res_conservative { cpus = Math.max(1, params.processes - params.free_processes) }
    withLabel: res_single_cpu { cpus = 1 }
}

singularity.autoMounts = true

//process {
//    scratch = true
//    stageInMode = 'copy'
//    stageOutMode = 'rsync'
//}

singularity.engineOptions = "--debug"
singularity.runOptions = "--nv"


// Required environment variables
env.FSLOUTPUTTYPE = 'NIFTI_GZ'


// Configuration profiles
profiles {
    hcp {
        process.executor = 'slurm'
        process.scratch = true
        process.stageInMode = 'copy'
        process.stageOutMode = 'rsync'
        executor.$slurm.queueSize = params.max_parallel_tasks
        executor.$slurm.submitRateLimit = params.submit_rate
    }
}

if ( params.max_time_per_task )
    process.time = params.max_time_per_task

if ( params.queue_type )
    process.queue = params.queue_type

if ( params.additional_cluster_opts )
    process.clusterOptions = params.cluster_opts
