from os import chmod
from os.path import basename

import nibabel as nib
import numpy as np
from traitlets import Dict, Instance, Unicode, Bool, Enum

from magic_monkey.base.application import (MagicMonkeyBaseApplication,
                                           output_prefix_argument,
                                           input_dwi_prefix)

from magic_monkey.base.fsl import prepare_acqp_file, prepare_eddy_index
from magic_monkey.base.dwi import load_metadata, save_metadata
from magic_monkey.base.scripting import build_script
from magic_monkey.config.eddy import EddyConfiguration

_aliases = {
    "in": 'Eddy.image',
    "acqp": 'Eddy.acquisition_file',
    "rev": 'Eddy.rev_image',
    "out": 'Eddy.output_prefix'
}

_flags = dict(
    rev_eddy=(
        {"Eddy": {"eddy_on_rev": True}},
        "Enables eddy correction on dwi and "
        "reverse acquisition concatenated together"
    )
)

_eddy_script = """
args=""
if [ $TOPUP ]
then
    args="$args --topup=$TOPUP"
fi
if [ $SCSFIELD ]
then
    args="$args --field=$SCSFIELD"
fi
if [ $SCSMAT ]
then
    args="$args --field_mat=$SCSMAT"
fi

base_args="--imain=$dwi --mask=$mask --acqp=$acqp --index=$index"
base_args="$base_args --bvecs=$bvecs --bvals=$bvals"

{executable} $base_args $args {more_args} --out {output}
"""

_description = """
Command-line utility used to parametrize and create scripts performing eddy 
correction on diffusion weighted images. For more information on the 
parameters available for the eddy executable, please refer to the website [1].

References :
------------
[1] https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/eddy
[Andersson 2016a] Jesper L. R. Andersson and Stamatios N. Sotiropoulos. 
                  An integrated approach to correction for off-resonance 
                  effects and subject movement in diffusion MR imaging. 
                  NeuroImage, 125:1063-1078, 2016.
"""


class Eddy(MagicMonkeyBaseApplication):
    name = u"Eddy"
    description = _description
    configuration = Instance(EddyConfiguration).tag(config=True)

    image = input_dwi_prefix()
    output_prefix = output_prefix_argument()

    acquisition_file = Unicode(
        help="Acquisition file describing the "
             "orientation and dwell of the volumes"
    ).tag(config=True)

    rev_image = input_dwi_prefix(
        description="Input reverse acquisition image prefix "
                    "(for image and bvals/bvecs/metadata if not b0)"
    ).tag(config=True)

    eddy_on_rev = Bool().tag(config=True)

    indexing_strategy = Enum(
        ["closest", "first"], "first",
        help="Strategy used to find which line in the .acqp aligns "
             "with which volume in the supplied dwi volume. For datasets "
             "with evenly spaced b0, \"closest\" will give the best result. "
             "In any other cases, or if you don't know, use \"first\""
    )

    aliases = Dict(_aliases)
    flags = Dict(_flags)

    def _validate_required(self):
        super()._validate_required()

    def _start(self):
        bvals = np.loadtxt("{}.bvals".format(self.image))
        metadata = load_metadata(self.image)
        if self.rev_image:
            rev_bvals = np.loadtxt("{}.bvals".format(self.rev_image))
            metadata.extend(load_metadata(self.rev_image))
        else:
            rev_bvals = np.array([])

        if not self.acquisition_file:
            acqp = prepare_acqp_file(
                [[np.count_nonzero(bvals == 0)]],
                [[np.count_nonzero(rev_bvals == 0)]],
                self.readout
            )

            with open("{}_acqp.txt".format(self.output_prefix), 'w+') as f:
                f.write("# MAGIC MONKEY -------------------------\n")
                f.write("# Autogenerated acquisition parameters file\n\n")
                f.write(acqp)

        indexes = prepare_eddy_index(bvals, 1)
        with open(
            "{}_index.txt".format(self.output_prefix), "w+"
        ) as f:
            f.write(" ".join([str(i) for i in indexes]))

        with open(
            "{}_script.sh".format(self.output_prefix), "w+"
        ) as f:
            eddy_exec = "eddy"
            if self.configuration.enable_cuda:
                eddy_exec += "_cuda"

            script = build_script(
                _eddy_script.format(
                    executable=eddy_exec,
                    output=self.output_prefix,
                    more_args=self.configuration.serialize()
                ),
                ["dwi", "bvals", "bvecs", "mask", "acqp", "index"],
                ["topup", "scsfield", "scsmat"],
                header="\n".join([
                    "# Preparing environment",
                    "CUDA_HOME=/usr/local/cuda-9.1",
                    "export LD_LIBRARY_PATH=" + ":".join([
                        "$CUDA_HOME/extras/CUPTI/lib64",
                        "$CUDA_HOME/lib64",
                        "$LD_LIBRARY_PATH"
                    ]),
                    "export PATH=$CUDA_HOME/bin:$PATH\n"
                ]) if self.configuration.enable_cuda else ""
            )
            f.write(script)

        chmod("{}_script.sh".format(self.output_prefix), 0o0777)

        metadata.multiband_corrected = (
            self.configuration.slice_to_vol is not None or
            self.configuration.susceptibility is not None
        ) or metadata.multiband_corrected

        save_metadata(self.output_prefix, metadata)
