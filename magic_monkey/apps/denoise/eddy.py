from os import chmod

import nibabel as nib
import numpy as np
from traitlets import Dict, Float, Instance, Unicode

from magic_monkey.base.application import (MagicMonkeyBaseApplication,
                                           output_prefix_argument,
                                           required_file,
                                           required_number)
from magic_monkey.base.fsl import prepare_acqp_file, prepare_eddy_index
from magic_monkey.base.scripting import build_script
from magic_monkey.config.eddy import EddyConfiguration

_aliases = dict(
    bvals='Eddy.bvals',
    acqp='Eddy.acquisition_file',
    rev='Eddy.rev_bvals',
    readout='Eddy.readout',
    out='Eddy.output_prefix'
)

_eddy_script = """
args=""
if [ $TOPUP ]
then
    args="$args --topup=$TOPUP"
fi
if [ $SCSFIELD ]
then
    args="$args --field=$SCSFIELD"
fi
if [ $SCSMAT ]
then
    args="$args --field_mat=$SCSMAT"
fi

base_args="--imain=$dwi --mask=$mask --acqp=$acqp --index=$index"
base_args="$base_args --bvecs=$bvecs --bvals=$bvals"

{executable} $base_args $args {more_args} --out {output}
"""

_description = """
Command-line utility used to parametrize and create scripts performing eddy 
correction on diffusion weighted images. For more information on the 
parameters available for the eddy executable, please refer to the website [1].

References :
------------
[1] https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/eddy
[Andersson 2016a] Jesper L. R. Andersson and Stamatios N. Sotiropoulos. 
                  An integrated approach to correction for off-resonance 
                  effects and subject movement in diffusion MR imaging. 
                  NeuroImage, 125:1063-1078, 2016.
"""


class Eddy(MagicMonkeyBaseApplication):
    name = u"Eddy"
    description = _description
    configuration = Instance(EddyConfiguration).tag(config=True)

    bvals = required_file(description="B-value file following fsl format")
    output_prefix = output_prefix_argument()

    acquisition_file = required_file(
        description="Acquisition file describing the "
                    "orientation and dwell of the volumes",
        exclusive_group="acqp", group_index=0
    )

    rev_bvals = Unicode(
        help="Bvals for the reverse phase acquisition, used "
             "to create the acquisition parameters file"
    ).tag(config=True, exclusive_group="acqp", group_index=1)

    readout = required_number(
        Float, exclusive_group="acqp", group_index=1,
        description="Readout time of the acquisitions in ms (from the"
                    "center of the first echo to the center of the last)"
    )

    aliases = Dict(_aliases)

    def _validate_required(self):
        super()._validate_required()

    def _start(self):
        bvals = np.loadtxt(self.bvals)
        if not self.acquisition_file:

            if self.rev_bvals:
                rev_bvals = np.loadtxt(self.rev_bvals)
            else:
                rev_bvals = np.array([])

            acqp = prepare_acqp_file(
                [[np.count_nonzero(bvals == 0)]],
                [[np.count_nonzero(rev_bvals == 0)]],
                self.readout
            )

            with open("{}_acqp.txt".format(self.output_prefix), 'w+') as f:
                f.write("# MAGIC MONKEY -------------------------\n")
                f.write("# Autogenerated acquisition parameters file\n\n")
                f.write(acqp)

        indexes = prepare_eddy_index(bvals, 1)
        with open(
            "{}_index.txt".format(self.output_prefix), "w+"
        ) as f:
            f.write(" ".join([str(i) for i in indexes]))

        with open(
            "{}_script.sh".format(self.output_prefix), "w+"
        ) as f:
            eddy_exec = "eddy"
            if self.configuration.enable_cuda:
                eddy_exec += "_cuda"

            script = build_script(
                _eddy_script.format(
                    executable=eddy_exec,
                    output=self.output_prefix,
                    more_args=self.configuration.serialize()
                ),
                ["dwi", "bvals", "bvecs", "mask", "acqp", "index"],
                ["topup", "scsfield", "scsmat"],
                header="\n".join([
                    "# Preparing environment",
                    "CUDA_HOME=/usr/local/cuda-9.1",
                    "export LD_LIBRARY_PATH=" + ":".join([
                        "$CUDA_HOME/extras/CUPTI/lib64",
                        "$CUDA_HOME/lib64",
                        "$LD_LIBRARY_PATH"
                    ]),
                    "export PATH=$CUDA_HOME/bin:$PATH\n"
                ]) if self.configuration.enable_cuda else ""
            )
            f.write(script)

        chmod("{}_script.sh".format(self.output_prefix), 0o0777)
