from os import chmod

import nibabel as nib
import numpy as np
from traitlets import Dict, Float, Instance

from magic_monkey.base.application import (MagicMonkeyBaseApplication,
                                           output_prefix_argument,
                                           required_file,
                                           required_number)
from magic_monkey.base.fsl import prepare_acqp_file, prepare_eddy_index
from magic_monkey.base.scripting import build_script
from magic_monkey.config.eddy import EddyConfiguration

_aliases = dict(
    bvals='Eddy.bvals',
    acqp='Eddy.acquisition_file',
    dwi='Eddy.dwi',
    rev='Eddy.rev',
    dwell='Eddy.dwell',
    out='Eddy.output_prefix'
)

_eddy_script = """
    args=""
    if [ $TOPUP ]
    then
        args="$args --topup=$TOPUP
    fi
    if [ $SCSFIELD ]
    then
        args="$args --field=$SCSFIELD
    fi
    if [ $SCSMAT ]
        args="$args --field_mat=$SCSMAT
    fi

    base_args="--imain=$dwi --mask=$mask --acqp=$acqp --index=$index"
    base_args="$base_args --bvecs=$bvecs --bvals=$bvals"

    {} --out {} $base_args $args {}
"""

_description = """
Command-line utility used to parametrize and create scripts performing eddy 
correction on diffusion weighted images. For more information on the 
parameters available for the eddy executable, please refer to the website [1].

References :
------------
[1] https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/eddy
[Andersson 2016a] Jesper L. R. Andersson and Stamatios N. Sotiropoulos. 
                  An integrated approach to correction for off-resonance 
                  effects and subject movement in diffusion MR imaging. 
                  NeuroImage, 125:1063-1078, 2016.
"""


class Eddy(MagicMonkeyBaseApplication):
    name = u"Eddy"
    description = _description
    configuration = Instance(EddyConfiguration).tag(config=True)

    bvals = required_file(description="B-value file following fsl format")
    output_prefix = output_prefix_argument()

    acquisition_file = required_file(
        description="Acquisition file describing the "
                    "orientation and dwell of the volumes",
        exclusive_group="acqp", group_index=0
    )

    dwi = required_file(
        description="Principal dwi volume used to configure "
                    "the acquisition parameters file",
        exclusive_group="acqp", group_index=1
    )
    rev = required_file(
        description="Reverse dwi volume used to configure "
                    "the acquisition parameters file",
        exclusive_group="acqp", group_index=1
    )
    dwell = required_number(
        Float, description="Dwell time of the acquisitions",
        exclusive_group="acqp", group_index=1
    )

    aliases = Dict(_aliases)

    def _validate_required(self):
        if self.rev:
            self.traits()["dwell"].tag(required=True)

        super()._validate_required()

    def _start(self):
        if self.rev:
            ap_shapes = [nib.load(dwi).shape for dwi in self.dwi]
            pa_shapes = [nib.load(vol).shape for vol in self.rev]

            acqp = prepare_acqp_file(ap_shapes, pa_shapes, self.dwell)
            with open("{}_acqp.txt".format(self.output_prefix), 'w+') as f:
                f.write("# MAGIC MONKEY -------------------------\n")
                f.write("# Autogenerated acquisition parameters file\n\n")
                f.write(acqp)

        bvals = np.loadtxt(self.bvals)
        indexes = prepare_eddy_index(bvals, 1)
        with open(
            "{}_eddy_index.txt".format(self.output_prefix), "w+"
        ) as f:
            f.write(" ".join([str(i) for i in indexes]))

        with open(
            "{}_script.sh".format(self.output_prefix), "w+"
        ) as f:
            eddy_exec = "eddy"
            if self.configuration.enable_cuda:
                eddy_exec += "_cuda"

            script = build_script(
                _eddy_script.format(
                    eddy_exec,
                    "{}.nii.gz".format(self.output_prefix),
                    self.configuration.serialize()
                ),
                ["dwi", "bvals", "bvecs", "mask", "acqp", "index"],
                ["topup", "scsfield", "scsmat"],
                header="\n".join([
                    "# Preparing environment",
                    "CUDA_HOME=/usr/local/cuda-9.1",
                    "export LD_LIBRARY_PATH=" + ":".join([
                        "$CUDA_HOME/extras/CUPTI/lib64",
                        "$CUDA_HOME/lib64",
                        "$LD_LIBRARY_PATH"
                    ]),
                    "export PATH=$CUDA_HOME/bin:$PATH\n"
                ]) if self.configuration.enable_cuda else ""
            )
            f.write(script)

        chmod("{}_script.sh".format(self.output_prefix), 0o0777)
